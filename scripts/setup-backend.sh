#!/bin/bash
#
# Azure Backend Setup Script for Terraform State
#
# This script creates the Azure infrastructure required for Terraform remote state:
# - Resource group for Terraform state
# - Storage account with encryption and HTTPS-only access
# - Blob container with versioning
# - Soft delete protection
# - Azure AD app registration for GitHub Actions (optional)
# - Workload identity federation credentials (optional)
#
# Prerequisites:
# - Azure CLI installed and logged in (az login)
# - Contributor access to Azure subscription
# - jq installed for JSON parsing
#
# Usage:
#   ./scripts/setup-backend.sh
#   ./scripts/setup-backend.sh --create-service-principal
#

set -e # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

print_success() {
  echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

print_error() {
  echo -e "${RED}❌ $1${NC}"
}

# Function to generate backend.local.hcl for manual CLI workflow
generate_backend_local_config() {
  local env_dir="$1"
  local backend_file="${env_dir}/backend.local.hcl"

  print_info "Generating backend.local.hcl for manual CLI workflow..."

  # Create directory if it doesn't exist
  mkdir -p "$env_dir"

  # Generate backend.local.hcl with actual values
  cat >"$backend_file" <<EOF
# Backend Configuration for Manual CLI Deployment
#
# This file was automatically generated by setup-backend.sh
# Generated on: $(date '+%Y-%m-%d %H:%M:%S')
#
# This configuration enables local Terraform operations using Azure CLI
# authentication (az login) when service principal setup is not available.
#
# Authentication Method: Azure CLI (az login)
# - Ensure you are logged in: az login
# - Set subscription: az account set --subscription $SUBSCRIPTION_ID
# - Required role: "Storage Blob Data Owner" on storage account
#
# Usage:
#   cd terraform/environments/dev
#   terraform init -backend-config=backend.local.hcl
#   terraform plan
#   terraform apply

# Azure Resource Group containing the storage account
resource_group_name = "$RESOURCE_GROUP"

# Storage account name (globally unique identifier)
storage_account_name = "$STORAGE_ACCOUNT"

# Container name within the storage account
container_name = "$CONTAINER_NAME"

# State file path within the container (unique per environment)
key = "dev/terraform.tfstate"

# Authentication Notes:
# - Azure CLI authentication is used by default when use_oidc is not set
# - Ensure 'az login' is run and correct subscription is selected
# - Required Azure permissions:
#   - "Contributor" role on resource group for deploying resources
#   - "Storage Blob Data Owner" role on storage account for state management
#
# For CI/CD with OIDC (GitHub Actions), see:
# - .github/workflows/terraform-*.yml (sets ARM_USE_OIDC=true)
# - terraform/backend.tf (backend configuration with OIDC support)
EOF

  if [ -f "$backend_file" ]; then
    print_success "Created: $backend_file"
    return 0
  else
    print_error "Failed to create backend.local.hcl"
    return 1
  fi
}

# Function to generate .env file for F5 XC credentials
generate_volterra_env_file() {
  local env_file=".env"

  print_info "Generating .env file with F5 XC credentials for manual CLI workflow..."

  # Create .env file in project root
  cat >"$env_file" <<'ENV_FILE_HEADER'
# F5 Distributed Cloud Provider Authentication
# Generated: GENERATION_TIMESTAMP
#
# These credentials enable Terraform to authenticate with F5 XC Console
# for managing Customer Edge sites and related resources.
#
# IMPORTANT: This file is gitignored. Never commit credentials to version control.

ENV_FILE_HEADER

  # Add timestamp (sed is more portable than trying to embed date in heredoc)
  sed -i.bak "s/GENERATION_TIMESTAMP/$(date '+%Y-%m-%d %H:%M:%S')/" "$env_file"
  rm -f "${env_file}.bak"

  # Append credentials based on authentication method
  if [ "$USE_P12_AUTH" = true ]; then
    cat >>"$env_file" <<ENV_FILE_CONTENT
# Volterra Provider Environment Variables (P12 Certificate Authentication)
export VOLT_API_URL="$VOLT_API_URL"
export VES_P12_CONTENT="$VES_P12_CONTENT"
export VES_P12_PASSWORD="$VES_P12_PASSWORD"
export TF_VAR_f5_xc_tenant="$F5_XC_TENANT"

# Alternative: Certificate and Key File Authentication
# Uncomment these lines and comment out VES_P12_* variables above to use cert/key files:
# export VOLT_API_CERT="$HOME/vescred.cert"
# export VOLT_API_KEY="$HOME/vesprivate.key"

# .vesconfig file created at: $HOME/.vesconfig
# Contains: server-urls, cert, and key paths for F5 XC CLI tools

# Usage Instructions:
#   1. Source this file before running Terraform:
#      source .env
#
#   2. Authenticate with Azure:
#      az login
#      az account set --subscription $SUBSCRIPTION_ID
#
#   3. Run Terraform commands:
#      cd terraform/environments/dev
#      terraform init -backend-config=backend.local.hcl
#      terraform plan
#      terraform apply
#
# Verification:
#   • Check credentials are loaded: env | grep VOLT
#   • Check credentials are loaded: env | grep VES_P12
#   • Check Terraform variables: env | grep TF_VAR_f5_xc
#   • Terraform should authenticate without prompts
ENV_FILE_CONTENT
  else
    cat >>"$env_file" <<ENV_FILE_CONTENT
# Volterra Provider Environment Variables (API Token - NOT SUPPORTED BY TERRAFORM!)
export VOLT_API_URL="$VOLT_API_URL"
export VOLT_API_KEY="$F5_XC_API_TOKEN"
export TF_VAR_f5_xc_tenant="$F5_XC_TENANT"
export TF_VAR_f5_xc_api_token="$F5_XC_API_TOKEN"

# WARNING: The Terraform provider does NOT support API tokens!
#          These credentials can only be used for direct API calls.
#          For Terraform operations, you MUST use P12 certificate authentication.
#
# To fix: Re-run setup-backend.sh and choose P12 certificate authentication.

# Usage Instructions (API calls only):
#   1. Source this file before making API calls:
#      source .env
#
#   2. Example API call:
#      curl -H "Authorization: APIToken \$VOLT_API_KEY" \\
#           \$VOLT_API_URL/web/namespaces
#
# For Terraform: You cannot proceed without P12 certificate authentication.
ENV_FILE_CONTENT
  fi

  # Set restrictive permissions
  chmod 600 "$env_file"

  if [ -f "$env_file" ]; then
    print_success "Created: $env_file (permissions: 600)"
    return 0
  else
    print_error "Failed to create .env file"
    return 1
  fi
}

# Check prerequisites
print_info "Checking prerequisites..."

if ! command -v az &>/dev/null; then
  print_error "Azure CLI not found. Please install: https://docs.microsoft.com/en-us/cli/azure/install-azure-cli"
  exit 1
fi

if ! command -v jq &>/dev/null; then
  print_warning "jq not found. Install for better JSON parsing: brew install jq (macOS) or apt-get install jq (Linux)"
fi

# Check if logged in to Azure
if ! az account show &>/dev/null; then
  print_warning "Not currently logged in to Azure"
  echo ""
  print_info "To continue, you need to authenticate with Azure"
  print_info "This will open a browser window for you to sign in"
  echo ""
  read -p "Press Enter to open Azure login in your browser, or Ctrl+C to cancel: " -r
  echo ""

  print_info "Initiating Azure login..."
  if az login; then
    print_success "Successfully logged in to Azure"
  else
    print_error "Azure login failed. Please check your credentials and try again"
    exit 1
  fi
  echo ""
else
  print_success "Already logged in to Azure"
fi

print_success "Prerequisites check passed"

# Get current subscription and user info
SUBSCRIPTION_ID=$(az account show --query id -o tsv)
TENANT_ID=$(az account show --query tenantId -o tsv)
SUBSCRIPTION_NAME=$(az account show --query name -o tsv)
AZURE_USERNAME=$(az account show --query user.name -o tsv | cut -d@ -f1 | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-')

# GitHub repository info (auto-detect from git remote)
GITHUB_REMOTE=$(git remote get-url origin 2>/dev/null || echo "")
if [ -n "$GITHUB_REMOTE" ]; then
  GITHUB_ORG=$(echo "$GITHUB_REMOTE" | sed -n 's/.*[:/]\([^/]*\)\/[^/]*$/\1/p')
  GITHUB_REPO=$(echo "$GITHUB_REMOTE" | sed -n 's/.*\/\([^/]*\)\.git$/\1/p')
else
  GITHUB_ORG="${GITHUB_ORG:-}"
  GITHUB_REPO="${GITHUB_REPO:-f5-xc-ce-terraform}"
fi

# Configuration with improved naming to prevent conflicts
# Azure resource group naming: alphanumeric + hyphens, max 90 chars
RESOURCE_GROUP="${RESOURCE_GROUP:-${AZURE_USERNAME}-${GITHUB_REPO}-tfstate}"
LOCATION="${LOCATION:-eastus}"
# Storage account: lowercase alphanumeric only, 3-24 chars, globally unique
# Format: tfstate + username_prefix(8) + unique_hash(8) = 23 chars total
if [ -z "$STORAGE_ACCOUNT" ]; then
  # Truncate username to first 8 chars
  USERNAME_PREFIX=$(echo "$AZURE_USERNAME" | cut -c1-8)
  # Create 8-char hash from username+subscription for uniqueness and determinism
  UNIQUE_HASH=$(echo -n "${AZURE_USERNAME}${SUBSCRIPTION_ID}" | md5sum | cut -c1-8)
  STORAGE_ACCOUNT="tfstate${USERNAME_PREFIX}${UNIQUE_HASH}"
fi
# Container: lowercase alphanumeric + hyphens, 3-63 chars, add '-tf' suffix
CONTAINER_BASE=$(echo -n "${AZURE_USERNAME}-${GITHUB_REPO}" | tr '[:upper:]' '[:lower:]')
CONTAINER_NAME="${CONTAINER_NAME:-$(echo "$CONTAINER_BASE" | cut -c1-60)-tf}"

print_info "Target Subscription: $SUBSCRIPTION_NAME ($SUBSCRIPTION_ID)"
print_info "Resource Group: $RESOURCE_GROUP"
print_info "Location: $LOCATION"
print_info "Storage Account: $STORAGE_ACCOUNT"
print_info "Container: $CONTAINER_NAME"
echo ""

read -p "Continue with these settings? (yes/no): " -r
if [[ ! $REPLY =~ ^[Yy](es)?$ ]]; then
  print_warning "Setup cancelled by user"
  exit 0
fi

echo ""
print_info "Step 1/8: Creating resource group..."

if az group show --name "$RESOURCE_GROUP" &>/dev/null; then
  print_warning "Resource group '$RESOURCE_GROUP' already exists"
else
  az group create \
    --name "$RESOURCE_GROUP" \
    --location "$LOCATION" \
    --tags environment=shared managed_by=terraform purpose=state-storage owner="$AZURE_USERNAME" project="$GITHUB_REPO" \
    --output none
  print_success "Resource group created: $RESOURCE_GROUP"
fi

echo ""
print_info "Step 2/8: Creating storage account..."

if az storage account show --name "$STORAGE_ACCOUNT" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
  print_warning "Storage account '$STORAGE_ACCOUNT' already exists"
else
  az storage account create \
    --name "$STORAGE_ACCOUNT" \
    --resource-group "$RESOURCE_GROUP" \
    --location "$LOCATION" \
    --sku Standard_LRS \
    --kind StorageV2 \
    --encryption-services blob \
    --https-only true \
    --min-tls-version TLS1_2 \
    --allow-blob-public-access false \
    --tags environment=shared managed_by=terraform purpose=state-storage owner="$AZURE_USERNAME" project="$GITHUB_REPO" \
    --output none
  print_success "Storage account created: $STORAGE_ACCOUNT"
fi

echo ""
print_info "Step 3/8: Creating blob container..."

if az storage container show --name "$CONTAINER_NAME" --account-name "$STORAGE_ACCOUNT" &>/dev/null 2>&1; then
  print_warning "Container '$CONTAINER_NAME' already exists"
else
  az storage container create \
    --name "$CONTAINER_NAME" \
    --account-name "$STORAGE_ACCOUNT" \
    --auth-mode login \
    --output none
  print_success "Blob container created: $CONTAINER_NAME"
fi

echo ""
print_info "Step 4/8: Configuring blob service properties..."

# Enable versioning
az storage account blob-service-properties update \
  --account-name "$STORAGE_ACCOUNT" \
  --resource-group "$RESOURCE_GROUP" \
  --enable-versioning true \
  --output none
print_success "Blob versioning enabled"

# Enable soft delete (30 days retention)
az storage account blob-service-properties update \
  --account-name "$STORAGE_ACCOUNT" \
  --resource-group "$RESOURCE_GROUP" \
  --enable-delete-retention true \
  --delete-retention-days 30 \
  --output none
print_success "Soft delete enabled (30-day retention)"

# Enable container soft delete
az storage account blob-service-properties update \
  --account-name "$STORAGE_ACCOUNT" \
  --resource-group "$RESOURCE_GROUP" \
  --enable-container-delete-retention true \
  --container-delete-retention-days 30 \
  --output none
print_success "Container soft delete enabled (30-day retention)"

echo ""
print_info "Step 5/8: Configuring access..."

# Get current user object ID for RBAC assignment
CURRENT_USER_ID=$(az ad signed-in-user show --query id -o tsv 2>/dev/null || echo "")

if [ -n "$CURRENT_USER_ID" ]; then
  # Assign Storage Blob Data Owner to current user
  if az role assignment list --assignee "$CURRENT_USER_ID" --scope "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Storage/storageAccounts/$STORAGE_ACCOUNT" --role "Storage Blob Data Owner" --query '[].id' -o tsv 2>/dev/null | grep -q .; then
    print_warning "Current user already has Storage Blob Data Owner role"
  else
    if az role assignment create \
      --role "Storage Blob Data Owner" \
      --assignee "$CURRENT_USER_ID" \
      --scope "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Storage/storageAccounts/$STORAGE_ACCOUNT" \
      --output none 2>/dev/null; then
      print_success "Assigned Storage Blob Data Owner role to current user"
    else
      print_warning "Failed to assign Storage Blob Data Owner role (insufficient permissions)"
      print_info "Please ask your Azure administrator to assign this role manually"
    fi
  fi
else
  print_warning "Could not determine current user ID - skipping RBAC assignment"
fi

# Create service principal for GitHub Actions (mandatory for OIDC)
echo ""
print_info "Step 6/8: Creating Azure AD App Registration for GitHub Actions..."

APP_NAME="GitHub-Actions-${GITHUB_REPO}"

# Check if app already exists (idempotent)
APP_ID=$(az ad app list --display-name "$APP_NAME" --query '[0].appId' -o tsv 2>/dev/null || echo "")

if [ -n "$APP_ID" ]; then
  print_warning "App registration '$APP_NAME' already exists with ID: $APP_ID"
else
  if APP_ID=$(az ad app create --display-name "$APP_NAME" --query appId -o tsv 2>/dev/null); then
    print_success "App registration created: $APP_NAME ($APP_ID)"
  else
    print_error "Failed to create app registration (insufficient permissions)"
    print_info "Please ask your Azure administrator to create the app registration"
    print_info "Skipping service principal and OIDC configuration"
    APP_ID=""
  fi
fi

# Create service principal if it doesn't exist (idempotent)
if [ -n "$APP_ID" ]; then
  if az ad sp show --id "$APP_ID" &>/dev/null; then
    print_warning "Service principal already exists"
  else
    if az ad sp create --id "$APP_ID" --output none 2>/dev/null; then
      print_success "Service principal created"
    else
      print_error "Failed to create service principal (insufficient permissions)"
      print_info "Please ask your Azure administrator to create the service principal"
      APP_ID=""
    fi
  fi
fi

# Only configure roles and OIDC if we have a service principal
if [ -n "$APP_ID" ]; then
  # Track whether both required roles are successfully assigned
  CONTRIBUTOR_ASSIGNED=false
  STORAGE_ROLE_ASSIGNED=false
  ROLES_ASSIGNED=false

  # Assign Contributor role at subscription level (idempotent)
  if az role assignment list --assignee "$APP_ID" --scope "/subscriptions/$SUBSCRIPTION_ID" --role "Contributor" --query '[].id' -o tsv 2>/dev/null | grep -q .; then
    print_warning "Service principal already has Contributor role"
    CONTRIBUTOR_ASSIGNED=true
  else
    if az role assignment create \
      --role "Contributor" \
      --assignee "$APP_ID" \
      --scope "/subscriptions/$SUBSCRIPTION_ID" \
      --output none 2>/dev/null; then
      print_success "Assigned Contributor role to service principal"
      CONTRIBUTOR_ASSIGNED=true
    else
      print_warning "Failed to assign Contributor role (insufficient permissions)"
      print_info "Please ask your Azure administrator to assign this role manually"
      CONTRIBUTOR_ASSIGNED=false
    fi
  fi

  # Assign Storage Blob Data Owner for state file access (idempotent)
  if az role assignment list --assignee "$APP_ID" --scope "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Storage/storageAccounts/$STORAGE_ACCOUNT" --role "Storage Blob Data Owner" --query '[].id' -o tsv 2>/dev/null | grep -q .; then
    print_warning "Service principal already has Storage Blob Data Owner role"
    STORAGE_ROLE_ASSIGNED=true
  else
    if az role assignment create \
      --role "Storage Blob Data Owner" \
      --assignee "$APP_ID" \
      --scope "/subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.Storage/storageAccounts/$STORAGE_ACCOUNT" \
      --output none 2>/dev/null; then
      print_success "Assigned Storage Blob Data Owner role for state access"
      STORAGE_ROLE_ASSIGNED=true
    else
      print_warning "Failed to assign Storage Blob Data Owner role (insufficient permissions)"
      print_info "Please ask your Azure administrator to assign this role manually"
      STORAGE_ROLE_ASSIGNED=false
    fi
  fi

  # Both roles must succeed for OIDC to work
  if [ "$CONTRIBUTOR_ASSIGNED" = true ] && [ "$STORAGE_ROLE_ASSIGNED" = true ]; then
    ROLES_ASSIGNED=true
  fi

  # Configure OIDC federated credentials for GitHub Actions
  echo ""
  print_info "Step 7/8: Configuring OIDC federated credentials..."

  if [ -z "$GITHUB_ORG" ]; then
    print_error "GitHub organization not detected. Please set GITHUB_ORG environment variable"
    exit 1
  fi

  # Federated credential for main branch (idempotent)
  CRED_NAME_MAIN="github-actions-main"
  if az ad app federated-credential show --id "$APP_ID" --federated-credential-id "$CRED_NAME_MAIN" &>/dev/null; then
    print_warning "Federated credential '$CRED_NAME_MAIN' already exists"
  else
    az ad app federated-credential create --id "$APP_ID" --parameters "{
      \"name\": \"$CRED_NAME_MAIN\",
      \"issuer\": \"https://token.actions.githubusercontent.com\",
      \"subject\": \"repo:$GITHUB_ORG/$GITHUB_REPO:ref:refs/heads/main\",
      \"audiences\": [\"api://AzureADTokenExchange\"]
    }" --output none
    print_success "Created federated credential for main branch"
  fi

  # Federated credential for pull requests (idempotent)
  CRED_NAME_PR="github-actions-pr"
  if az ad app federated-credential show --id "$APP_ID" --federated-credential-id "$CRED_NAME_PR" &>/dev/null; then
    print_warning "Federated credential '$CRED_NAME_PR' already exists"
  else
    az ad app federated-credential create --id "$APP_ID" --parameters "{
      \"name\": \"$CRED_NAME_PR\",
      \"issuer\": \"https://token.actions.githubusercontent.com\",
      \"subject\": \"repo:$GITHUB_ORG/$GITHUB_REPO:pull_request\",
      \"audiences\": [\"api://AzureADTokenExchange\"]
    }" --output none
    print_success "Created federated credential for pull requests"
  fi
else
  echo ""
  print_warning "Skipping role assignments and OIDC configuration (no service principal)"
  ROLES_ASSIGNED=false
fi

# Prompt for F5 Distributed Cloud (Volterra) credentials
echo ""
print_info "Step 7.5/8: F5 Distributed Cloud (Volterra) Configuration..."

echo ""
echo -e "${BLUE}F5 Distributed Cloud Provider Configuration${NC}"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# P12 Certificate generation instructions (shown before discovery)
echo -e "${YELLOW}F5 XC P12 Certificate Authentication${NC}"
echo "The Terraform provider requires P12 certificate-based authentication."
echo ""
echo -e "${YELLOW}P12 Certificate Generation Instructions:${NC}"
echo "  1. Login to F5 XC Console: https://[tenant].console.ves.volterra.io"
echo "  2. Navigate to: Administration > Personal Management > Credentials"
echo "  3. Click 'Add Credentials' > 'API Certificate' (NOT API Token!)"
echo "  4. Download the .p12 file and save the password"
echo ""

# Discover P12 files in Downloads directory
print_info "Searching for P12 certificates in ~/Downloads..."
P12_FILES=()
while IFS= read -r -d '' file; do
  P12_FILES+=("$file")
done < <(find "$HOME/Downloads" -maxdepth 1 -name "*.console.ves.volterra.io.api-creds.p12" -print0 2>/dev/null)

DISCOVERED_TENANT=""
P12_FILE_PATH=""

if [ ${#P12_FILES[@]} -eq 0 ]; then
  # No P12 files found - fall back to manual entry
  print_warning "No P12 certificates found in ~/Downloads/"
  echo ""

  # Prompt for tenant name first
  read -p "Enter your F5 XC tenant name (e.g., 'my-company' from my-company.console.ves.volterra.io): " F5_XC_TENANT

  # Validate tenant name format
  if [[ -z "$F5_XC_TENANT" ]]; then
    print_error "Tenant name cannot be empty"
    exit 1
  elif [[ ! "$F5_XC_TENANT" =~ ^[a-z0-9][a-z0-9-]*[a-z0-9]$ ]] && [[ ! "$F5_XC_TENANT" =~ ^[a-z0-9]$ ]]; then
    print_error "Invalid tenant name format. Use lowercase alphanumeric characters and hyphens only."
    print_info "Tenant name must start and end with alphanumeric character"
    exit 1
  fi

  # Then prompt for P12 file path
  DEFAULT_P12_PATH="$HOME/Downloads/${F5_XC_TENANT}.console.ves.volterra.io.api-creds.p12"
  print_info "Expected P12 file location: $DEFAULT_P12_PATH"
  echo ""
  read -p "Enter the full path to your P12 certificate file: " P12_FILE_PATH
  P12_FILE_PATH="${P12_FILE_PATH/#\~/$HOME}"

elif [ ${#P12_FILES[@]} -eq 1 ]; then
  # Single P12 file found - auto-select and extract tenant
  P12_FILE_PATH="${P12_FILES[0]}"
  FILENAME=$(basename "$P12_FILE_PATH")

  # Extract tenant ID from filename (everything before .console.ves.volterra.io)
  DISCOVERED_TENANT=$(echo "$FILENAME" | sed 's/\.console\.ves\.volterra\.io\.api-creds\.p12$//')

  print_success "Found P12 certificate: $P12_FILE_PATH"
  print_info "Extracted tenant ID: $DISCOVERED_TENANT"
  echo ""

  # Prompt for tenant confirmation with extracted value as default
  read -p "Press Enter to use tenant '$DISCOVERED_TENANT', or type a different tenant name: " USER_TENANT

  if [ -z "$USER_TENANT" ]; then
    F5_XC_TENANT="$DISCOVERED_TENANT"
    print_success "Using tenant: $F5_XC_TENANT"
  else
    F5_XC_TENANT="$USER_TENANT"
    print_info "Using custom tenant: $F5_XC_TENANT"

    # Validate custom tenant name format
    if [[ ! "$F5_XC_TENANT" =~ ^[a-z0-9][a-z0-9-]*[a-z0-9]$ ]] && [[ ! "$F5_XC_TENANT" =~ ^[a-z0-9]$ ]]; then
      print_error "Invalid tenant name format. Use lowercase alphanumeric characters and hyphens only."
      print_info "Tenant name must start and end with alphanumeric character"
      exit 1
    fi
  fi

else
  # Multiple P12 files found - show selection menu
  print_success "Found ${#P12_FILES[@]} P12 certificates:"
  echo ""

  for i in "${!P12_FILES[@]}"; do
    FILENAME=$(basename "${P12_FILES[$i]}")
    echo "  $((i + 1))) $FILENAME"
  done
  echo ""

  # Prompt for selection
  while true; do
    read -p "Select certificate (1-${#P12_FILES[@]}): " SELECTION

    # Validate selection is a number in range
    if [[ "$SELECTION" =~ ^[0-9]+$ ]] && [ "$SELECTION" -ge 1 ] && [ "$SELECTION" -le ${#P12_FILES[@]} ]; then
      P12_FILE_PATH="${P12_FILES[$((SELECTION - 1))]}"
      FILENAME=$(basename "$P12_FILE_PATH")

      # Extract tenant ID from selected filename
      DISCOVERED_TENANT=$(echo "$FILENAME" | sed 's/\.console\.ves\.volterra\.io\.api-creds\.p12$//')

      print_success "Selected: $FILENAME"
      print_info "Extracted tenant ID: $DISCOVERED_TENANT"
      echo ""

      # Prompt for tenant confirmation with extracted value as default
      read -p "Press Enter to use tenant '$DISCOVERED_TENANT', or type a different tenant name: " USER_TENANT

      if [ -z "$USER_TENANT" ]; then
        F5_XC_TENANT="$DISCOVERED_TENANT"
        print_success "Using tenant: $F5_XC_TENANT"
      else
        F5_XC_TENANT="$USER_TENANT"
        print_info "Using custom tenant: $F5_XC_TENANT"

        # Validate custom tenant name format
        if [[ ! "$F5_XC_TENANT" =~ ^[a-z0-9][a-z0-9-]*[a-z0-9]$ ]] && [[ ! "$F5_XC_TENANT" =~ ^[a-z0-9]$ ]]; then
          print_error "Invalid tenant name format. Use lowercase alphanumeric characters and hyphens only."
          print_info "Tenant name must start and end with alphanumeric character"
          exit 1
        fi
      fi
      break
    else
      print_error "Invalid selection. Please enter a number between 1 and ${#P12_FILES[@]}"
    fi
  done
fi

# Construct API URL
VOLT_API_URL="https://${F5_XC_TENANT}.console.ves.volterra.io/api"
echo ""
print_success "Tenant: $F5_XC_TENANT"
print_info "API URL: $VOLT_API_URL"
echo ""

# If P12 file path not set yet (manual entry), prompt for it now
if [ -z "$P12_FILE_PATH" ]; then
  DEFAULT_P12_PATH="$HOME/Downloads/${F5_XC_TENANT}.console.ves.volterra.io.api-creds.p12"

  if [ -f "$DEFAULT_P12_PATH" ]; then
    print_info "Found P12 file: $DEFAULT_P12_PATH"
    echo ""
    read -p "Press Enter to use this file, or enter alternate path: " USER_P12_PATH

    if [ -z "$USER_P12_PATH" ]; then
      P12_FILE_PATH="$DEFAULT_P12_PATH"
      print_success "Using P12 file: $P12_FILE_PATH"
    else
      P12_FILE_PATH="${USER_P12_PATH/#\~/$HOME}"
    fi
  else
    print_warning "Default P12 file not found at: $DEFAULT_P12_PATH"
    echo ""
    read -p "Enter the full path to your P12 certificate file: " P12_FILE_PATH
    P12_FILE_PATH="${P12_FILE_PATH/#\~/$HOME}"
  fi
fi

# Validate P12 file exists
if [ ! -f "$P12_FILE_PATH" ]; then
  print_error "P12 file not found: $P12_FILE_PATH"
  print_info "Please verify the file path and ensure the P12 certificate exists"
  exit 1
fi

# Validate it's actually a P12 file (check extension)
if [[ ! "$P12_FILE_PATH" =~ \.p12$ ]]; then
  print_error "File must have .p12 extension: $P12_FILE_PATH"
  print_info "Please provide a valid P12 certificate file"
  exit 1
fi

print_success "Found P12 file: $P12_FILE_PATH"

# Prompt for P12 password (securely) - support environment variable
echo ""

# Check if password already set in environment
if [ -n "$VES_P12_PASSWORD" ]; then
  print_info "P12 password found in environment variable"
  echo ""
  read -p "Use existing password? (yes/no/show): " PASSWORD_CHOICE

  case "$PASSWORD_CHOICE" in
    yes | YES | y | Y | "")
      print_success "Using existing password from environment"
      ;;
    show)
      echo "Current password: $VES_P12_PASSWORD"
      read -p "Press Enter to use this password, or type new password: " NEW_PASSWORD
      if [ -n "$NEW_PASSWORD" ]; then
        VES_P12_PASSWORD="$NEW_PASSWORD"
        print_success "Using new password"
      else
        print_success "Using existing password"
      fi
      ;;
    no | NO | n | N)
      read -sp "Enter new P12 certificate password: " VES_P12_PASSWORD
      echo ""
      print_success "Using new password"
      ;;
    *)
      print_error "Invalid choice. Please answer yes, no, or show."
      exit 1
      ;;
  esac
else
  # No existing password - prompt securely
  read -sp "Enter the P12 certificate password: " VES_P12_PASSWORD
  echo ""
  print_success "P12 password received"
fi

# Validate password is not empty
if [ -z "$VES_P12_PASSWORD" ]; then
  print_error "P12 password cannot be empty"
  exit 1
fi

# Extract certificate and private key using openssl
echo ""
print_info "Extracting certificate and private key from P12 file..."

# Set output paths
CERT_FILE="$HOME/vescred.cert"
KEY_FILE="$HOME/vesprivate.key"

# Extract certificate using stdin for password (more reliable across platforms)
# Note: OpenSSL 3.x requires explicit provider flags for legacy algorithms (RC2-40-CBC)
# F5 XC P12 files use pbeWithSHA1And40BitRC2-CBC encryption
echo "$VES_P12_PASSWORD" | openssl pkcs12 \
  -in "$P12_FILE_PATH" \
  -passin stdin \
  -nodes \
  -nokeys \
  -provider legacy \
  -provider default \
  -out "$CERT_FILE" 2>&1 | grep -v "^MAC verified OK$" || true

if [ ! -f "$CERT_FILE" ] || [ ! -s "$CERT_FILE" ]; then
  print_error "Failed to extract certificate from P12 file"
  print_info "Verify the P12 password is correct and file is not corrupted"
  exit 1
fi

# Extract private key using stdin for password (more reliable across platforms)
# Note: OpenSSL 3.x requires explicit provider flags for legacy algorithms (RC2-40-CBC)
# F5 XC P12 files use pbeWithSHA1And40BitRC2-CBC encryption
echo "$VES_P12_PASSWORD" | openssl pkcs12 \
  -in "$P12_FILE_PATH" \
  -passin stdin \
  -nodes \
  -nocerts \
  -provider legacy \
  -provider default \
  -out "$KEY_FILE" 2>&1 | grep -v "^MAC verified OK$" || true

if [ ! -f "$KEY_FILE" ] || [ ! -s "$KEY_FILE" ]; then
  print_error "Failed to extract private key from P12 file"
  rm -f "$CERT_FILE" # Clean up partial extraction
  exit 1
fi

# Set restrictive permissions
chmod 600 "$CERT_FILE" "$KEY_FILE"

print_success "Certificate extracted: $CERT_FILE"
print_success "Private key extracted: $KEY_FILE"

# Create .vesconfig file
echo ""
print_info "Creating .vesconfig file..."

VESCONFIG_FILE="$HOME/.vesconfig"
cat >"$VESCONFIG_FILE" <<EOF
server-urls: $VOLT_API_URL
key: $KEY_FILE
cert: $CERT_FILE
EOF

chmod 600 "$VESCONFIG_FILE"
print_success "Created .vesconfig: $VESCONFIG_FILE"

# Base64 encode P12 for environment variable (optional, for Terraform provider)
echo ""
print_info "Encoding P12 certificate for Terraform provider..."
VES_P12_CONTENT=$(base64 -i "$P12_FILE_PATH" | tr -d '\n')
print_success "P12 certificate encoded (${#VES_P12_CONTENT} bytes)"

# Set authentication method flag
USE_P12_AUTH=true
F5_XC_API_TOKEN="" # Clear token if set

# Create GitHub secrets only if roles were successfully assigned
# Otherwise, configure manual CLI workflow
SECRETS_CREATED=false
SECRETS_SKIPPED=false

if [ -n "$APP_ID" ] && [ "$ROLES_ASSIGNED" = true ]; then
  # OIDC workflow is available - create GitHub secrets
  echo ""
  print_info "Step 8/8: Creating GitHub secrets..."

  if ! command -v gh &>/dev/null; then
    print_warning "GitHub CLI (gh) not found. Skipping GitHub secrets creation"
    print_info "Install gh CLI: https://cli.github.com/"
    SECRETS_SKIPPED=true
  else
    # Check if authenticated to GitHub
    if ! gh auth status &>/dev/null; then
      print_warning "Not authenticated to GitHub. Skipping secrets creation"
      print_info "Run: gh auth login"
      SECRETS_SKIPPED=true
    else
      # Set secrets (idempotent - gh secret set overwrites if exists)
      # Capture errors for better diagnostics
      SECRET_COUNT=0
      FAILED_SECRETS=()

      # Helper function to set secret with error reporting
      set_secret() {
        local value="$1"
        local name="$2"
        local error_output

        if [ -z "$value" ]; then
          print_warning "Skipping $name (value is empty)"
          return 1
        fi

        if error_output=$(echo "$value" | gh secret set "$name" --repo "$GITHUB_ORG/$GITHUB_REPO" 2>&1); then
          print_success "Set $name secret"
          ((SECRET_COUNT++))
          return 0
        else
          print_error "Failed to set $name: $error_output"
          FAILED_SECRETS+=("$name")
          return 1
        fi
      }

      # Create all secrets
      set_secret "$SUBSCRIPTION_ID" "AZURE_SUBSCRIPTION_ID"
      set_secret "$TENANT_ID" "AZURE_TENANT_ID"
      set_secret "$APP_ID" "AZURE_CLIENT_ID"
      set_secret "$RESOURCE_GROUP" "ARM_RESOURCE_GROUP_NAME"
      set_secret "$STORAGE_ACCOUNT" "ARM_STORAGE_ACCOUNT_NAME"
      set_secret "$CONTAINER_NAME" "ARM_CONTAINER_NAME"
      set_secret "terraform.tfstate" "ARM_KEY"

      # F5 XC secrets (conditional based on authentication method)
      if [ "$USE_P12_AUTH" = true ]; then
        set_secret "$VES_P12_CONTENT" "VES_P12_CONTENT"
        set_secret "$VES_P12_PASSWORD" "VES_P12_PASSWORD"
      else
        set_secret "$F5_XC_API_TOKEN" "F5_XC_API_TOKEN"
      fi
      set_secret "$VOLT_API_URL" "VOLT_API_URL"
      set_secret "$F5_XC_TENANT" "F5_XC_TENANT"

      # Evaluate results (10 total: 7 Azure + 3 F5 XC)
      if [ $SECRET_COUNT -eq 10 ]; then
        SECRETS_CREATED=true
        echo ""
        print_success "Successfully created all $SECRET_COUNT GitHub secrets"
      elif [ $SECRET_COUNT -gt 0 ]; then
        echo ""
        print_warning "Created $SECRET_COUNT secrets, but ${#FAILED_SECRETS[@]} failed: ${FAILED_SECRETS[*]}"
        print_info "Common issues:"
        print_info "  • Repository permissions: Ensure you have admin access to $GITHUB_ORG/$GITHUB_REPO"
        print_info "  • Auth scopes: Run 'gh auth refresh -s admin:org -s repo' to update permissions"
      else
        SECRETS_SKIPPED=true
        echo ""
        print_error "Failed to create any GitHub secrets"
        print_info "Check 'gh auth status' and repository permissions"
      fi
    fi
  fi
else
  # Roles not assigned or no service principal - configure manual CLI workflow
  echo ""
  print_warning "Skipping GitHub secrets creation (OIDC requires role assignments)"

  # Generate backend.local.hcl for manual CLI workflow
  echo ""
  print_info "Configuring manual CLI workflow as fallback..."

  # Determine terraform environment directory
  TERRAFORM_ENV_DIR="$(pwd)/terraform/environments/dev"

  if generate_backend_local_config "$TERRAFORM_ENV_DIR"; then
    print_success "Azure backend configuration created"
  else
    print_warning "Could not generate backend.local.hcl automatically"
    print_info "Please manually copy and edit: terraform/environments/dev/backend.local.hcl.example"
  fi

  # Generate .env file for F5 XC credentials
  echo ""
  if generate_volterra_env_file; then
    print_success "F5 XC credentials configured for manual CLI"
  else
    print_warning "Could not generate .env file automatically"
  fi

  SECRETS_CREATED=false
  SECRETS_SKIPPED=true
fi

# Configure GitHub workflow toggle based on role assignment status
# This variable controls whether Azure-dependent workflows (init, plan, apply) run
echo ""
print_info "Configuring GitHub Actions workflow toggle..."

if command -v gh &>/dev/null && gh auth status &>/dev/null 2>&1; then
  if [ -n "$APP_ID" ] && [ "$ROLES_ASSIGNED" = true ]; then
    # Roles successfully assigned - enable Azure workflows
    if echo "true" | gh variable set ENABLE_AZURE_WORKFLOWS --repo "$GITHUB_ORG/$GITHUB_REPO" 2>/dev/null; then
      print_success "Enabled Azure workflows (ENABLE_AZURE_WORKFLOWS=true)"
      print_info "GitHub Actions will run terraform init/plan/apply with OIDC authentication"
    else
      print_warning "Could not set ENABLE_AZURE_WORKFLOWS variable automatically"
      print_info "Set manually: gh variable set ENABLE_AZURE_WORKFLOWS --body 'true' --repo $GITHUB_ORG/$GITHUB_REPO"
    fi
  elif [ -n "$APP_ID" ] && [ "$ROLES_ASSIGNED" = false ]; then
    # Service principal exists but roles not assigned - disable Azure workflows
    if echo "false" | gh variable set ENABLE_AZURE_WORKFLOWS --repo "$GITHUB_ORG/$GITHUB_REPO" 2>/dev/null; then
      print_warning "Disabled Azure workflows (ENABLE_AZURE_WORKFLOWS=false)"
      print_info "Reason: Service principal lacks required role assignments"
      print_info "Only terraform-validate will run in GitHub Actions"
      echo ""
      print_info "To enable Azure workflows after assigning roles:"
      print_info "  gh variable set ENABLE_AZURE_WORKFLOWS --body 'true' --repo $GITHUB_ORG/$GITHUB_REPO"
    else
      print_warning "Could not set ENABLE_AZURE_WORKFLOWS variable automatically"
      print_info "Set manually: gh variable set ENABLE_AZURE_WORKFLOWS --body 'false' --repo $GITHUB_ORG/$GITHUB_REPO"
    fi
  else
    # No service principal created
    print_info "No service principal - skipping workflow toggle configuration"
  fi
else
  print_warning "GitHub CLI not available or not authenticated - skipping workflow toggle"
  print_info "You can manually set the variable later:"
  if [ "$ROLES_ASSIGNED" = true ]; then
    print_info "  gh variable set ENABLE_AZURE_WORKFLOWS --body 'true' --repo $GITHUB_ORG/$GITHUB_REPO"
  else
    print_info "  gh variable set ENABLE_AZURE_WORKFLOWS --body 'false' --repo $GITHUB_ORG/$GITHUB_REPO"
  fi
fi

# Summary
echo ""
print_success "✨ Azure backend setup complete!"
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ "$SECRETS_CREATED" = true ] && [ "$SECRETS_SKIPPED" = false ]; then
  echo "  Setup Summary"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo "✅ Azure Resources Created:"
  echo "   • Resource Group: $RESOURCE_GROUP"
  echo "   • Storage Account: $STORAGE_ACCOUNT"
  echo "   • Blob Container: $CONTAINER_NAME"
  echo ""
  echo "✅ GitHub Secrets Created Automatically:"
  echo "   Azure Authentication:"
  echo "   • AZURE_SUBSCRIPTION_ID, AZURE_TENANT_ID"
  if [ -n "$APP_ID" ]; then
    echo "   • AZURE_CLIENT_ID"
  fi
  echo "   • ARM_RESOURCE_GROUP_NAME, ARM_STORAGE_ACCOUNT_NAME"
  echo "   • ARM_CONTAINER_NAME, ARM_KEY"
  echo ""
  echo "   F5 Distributed Cloud:"
  if [ "$USE_P12_AUTH" = true ]; then
    echo "   • VES_P12_CONTENT - Base64-encoded P12 certificate"
    echo "   • VES_P12_PASSWORD - P12 certificate password"
  else
    echo "   • F5_XC_API_TOKEN - API Token (NOT for Terraform!)"
  fi
  echo "   • VOLT_API_URL - Tenant API endpoint ($VOLT_API_URL)"
  echo "   • F5_XC_TENANT - Tenant name ($F5_XC_TENANT)"
  echo ""
  echo "✅ GitHub Actions: ENABLED"
  echo "   • terraform-validate: ✓ Runs on all PRs"
  echo "   • terraform-plan: ✓ PR validation with OIDC"
  echo "   • terraform-apply: ✓ Auto-deploy on main branch"
  echo ""
  echo "Next Steps:"
  echo "  1. Push changes to trigger GitHub Actions"
  echo "  2. Open PR to test terraform-plan workflow"
  echo "  3. Merge PR to trigger terraform-apply"
else
  echo "  SAVE THESE VALUES - Required for Terraform and GitHub Secrets"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo "Backend Configuration (for terraform init):"
  echo "  ARM_RESOURCE_GROUP_NAME=\"$RESOURCE_GROUP\""
  echo "  ARM_STORAGE_ACCOUNT_NAME=\"$STORAGE_ACCOUNT\""
  echo "  ARM_CONTAINER_NAME=\"$CONTAINER_NAME\""
  echo "  ARM_KEY=\"terraform.tfstate\""
  echo ""
  echo "Azure Credentials (for GitHub Secrets):"
  echo "  AZURE_SUBSCRIPTION_ID=\"$SUBSCRIPTION_ID\""
  echo "  AZURE_TENANT_ID=\"$TENANT_ID\""
  if [ -n "$APP_ID" ]; then
    echo "  AZURE_CLIENT_ID=\"$APP_ID\""
  fi
  echo ""
  if [ "$ROLES_ASSIGNED" = false ]; then
    echo "⚠️  GitHub Actions Workflows:"
    echo "   • ENABLE_AZURE_WORKFLOWS=false (Azure workflows disabled)"
    echo "   • Reason: Service principal lacks required role assignments"
    echo "   • Only terraform-validate will run in GitHub Actions"
    echo "   • To enable after assigning roles:"
    echo "     gh variable set ENABLE_AZURE_WORKFLOWS --body 'true' --repo $GITHUB_ORG/$GITHUB_REPO"
    echo ""
  fi
  echo "Next Steps:"

  # Check if backend.local.hcl was generated
  if [ -f "terraform/environments/dev/backend.local.hcl" ] && [ -f ".env" ]; then
    echo "  1. ✅ Configuration files generated for manual CLI workflow:"
    echo "     • terraform/environments/dev/backend.local.hcl - Backend config"
    echo "     • .env - F5 XC credentials"
    echo ""
    echo "  2. For local development:"
    echo "     source .env"
    echo "     az login"
    echo "     az account set --subscription $SUBSCRIPTION_ID"
    echo "     cd terraform/environments/dev"
    echo "     terraform init -backend-config=backend.local.hcl"
    echo "     terraform plan"
    echo ""
    echo "  3. To enable GitHub Actions CI/CD, add these secrets manually:"
  else
    echo "  1. For local development, create configuration files:"
    echo "     cd terraform/environments/dev"
    echo "     cp backend.local.hcl.example backend.local.hcl"
    echo "     # Edit with values shown above"
    echo ""
    echo "  2. To enable GitHub Actions CI/CD, add these secrets:"
  fi

  echo "     # Azure secrets"
  echo "     gh secret set AZURE_SUBSCRIPTION_ID --body \"\$SUBSCRIPTION_ID\" --repo $GITHUB_ORG/$GITHUB_REPO"
  echo "     gh secret set AZURE_TENANT_ID --body \"\$TENANT_ID\" --repo $GITHUB_ORG/$GITHUB_REPO"
  if [ -n "$APP_ID" ]; then
    echo "     gh secret set AZURE_CLIENT_ID --body \"\$APP_ID\" --repo $GITHUB_ORG/$GITHUB_REPO"
  fi
  echo "     gh secret set ARM_RESOURCE_GROUP_NAME --body \"\$RESOURCE_GROUP\" --repo $GITHUB_ORG/$GITHUB_REPO"
  echo "     gh secret set ARM_STORAGE_ACCOUNT_NAME --body \"\$STORAGE_ACCOUNT\" --repo $GITHUB_ORG/$GITHUB_REPO"
  echo "     gh secret set ARM_CONTAINER_NAME --body \"\$CONTAINER_NAME\" --repo $GITHUB_ORG/$GITHUB_REPO"
  echo "     gh secret set ARM_KEY --body \"terraform.tfstate\" --repo $GITHUB_ORG/$GITHUB_REPO"
  echo ""
  echo "     # F5 XC secrets"
  if [ "$USE_P12_AUTH" = true ]; then
    echo "     echo \"\$VES_P12_CONTENT\" | gh secret set VES_P12_CONTENT --repo $GITHUB_ORG/$GITHUB_REPO"
    echo "     echo \"\$VES_P12_PASSWORD\" | gh secret set VES_P12_PASSWORD --repo $GITHUB_ORG/$GITHUB_REPO"
  else
    echo "     echo \"\$F5_XC_API_TOKEN\" | gh secret set F5_XC_API_TOKEN --repo $GITHUB_ORG/$GITHUB_REPO"
  fi
  echo "     echo \"$VOLT_API_URL\" | gh secret set VOLT_API_URL --repo $GITHUB_ORG/$GITHUB_REPO"
  echo "     echo \"$F5_XC_TENANT\" | gh secret set F5_XC_TENANT --repo $GITHUB_ORG/$GITHUB_REPO"
fi

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
